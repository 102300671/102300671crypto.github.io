<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto-RSA(一)</title>
    <link rel="stylesheet" href="/102300671crypto.github.io/assets/css/default.css">
    <link rel="stylesheet" href="/102300671crypto.github.io/assets/css/syntax.css">
    
      <!-- 生成语法高亮CSS的Liquid模板 -->

  <link rel="stylesheet" href="/102300671crypto.github.io/assets/css/syntax.css">
  <style>
    /* 行号列增强样式 */
   .highlight .lineno {
      color: #666;
      border-right: 1px solid #ddd;
      padding-right: 1em;
      user-select: none;
    }
    /* 代码块响应式适配 */
   .highlight pre {
      overflow-x: auto;
      padding: 1rem;
    }
  </style>
  
  </style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/default.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/highlight.min.js"></script>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  });
</script>
<script>
MathJax = {
  tex: {
    inlineMath: [['$','$'], ['\\(','\\)']],  // 行内公式标识符
    displayMath: [['\\[', '\\]']],  // 块级公式标识符，优先使用[\[,\]]避免冲突
    processEnvironments: true,  // 处理复杂公式环境
    packages: {'[+]': ['ams', 'color']}  // 扩展AMS数学包，根据实际使用情况调整
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],  // 忽略代码块
    ignoreHtmlClass: 'tex2jax_ignore'  // 指定忽略渲染的CSS类
  },
  svg: {
    fontCache: 'global',  // 字体缓存优化
    scale: 1.05  // 显示缩放调整
  }
};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
<style>
  .code-snippet {
    border: 1px solid #e1e4e8;
    border-radius: 6px;
    margin: 1em 0;
  }

  .code-header {
    background: #f6f8fa;
    padding: 8px 12px;
    display: flex;
    justify-content: space-between;
    border-bottom: 1px solid #e1e4e8;
  }

  .copy-button {
    cursor: pointer;
    color: #0366d6;
  }

  .copy-button:hover {
    text-decoration: underline;
  }

  .file-path {
    font-size: 0.85em;
    color: #586069;
    padding: 8px 12px;
    border-top: 1px solid #e1e4e8;
  }
</style>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('.copy-button').forEach((btn) => {
      btn.addEventListener('click', () => {
        const codeBlock = btn.parentNode.nextElementSibling.querySelector('code');
        navigator.clipboard.writeText(codeBlock.textContent).then(() => {
          btn.textContent = '已复制!';
          setTimeout(() => (btn.textContent = '复制'), 2000);
        });
      });
    });
  });
</script>

    
    
      <script>
MathJax = {
  tex: {
    inlineMath: [['$','$'], ['\\(','\\)']],  // 行内公式标识符
    displayMath: [['$$','$$'], ['\\[','\\]']],  // 块级公式标识符
    processEnvironments: true,  // 处理复杂公式环境
    packages: {'[+]': ['ams', 'color']}  // 扩展AMS数学包
  },
  options: {
    skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre'],  // 忽略代码块
    ignoreHtmlClass: 'tex2jax_ignore'  // 指定忽略渲染的CSS类
  },
  svg: {
    fontCache: 'global',  // 字体缓存优化
    scale: 1.05  // 显示缩放调整
  }
};
</script>
<script defer src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>

    
</head>
<body>
    <header>
        <h1>Crypto-RSA(一)</h1>
    </header>
    <main>
      <div class="code-container">
        <h2 id="nssctf">nssctf</h2>

<h2 id="rsa1p1">[RSA1]P1</h2>

<div class="code-snippet">
  <div class="code-header">
    <span class="file-name">main1.py</span>
  </div>
  <pre><code class="language-python">from Crypto.Util.number import inverse,long_to_bytes
'''
flag = b'NSSCTF{******}'
p = getPrime(512)
q = getPrime(512)
n = p*q
e = 65537
phi = (p-1)*(q-1)
m = bytes_to_long(flag)
c = pow(m, e, n)
print(f'p = {p}')
print(f'q = {q}')
print(f'e = {e}')
print(f'c = {c}')
'''
p = 10554915510546378513140074459658086644656654144905337809416976066414771647836950941616441505897207397834928781511863699153349798682451297889979721668885951
q = 8246403321715011123191410826902524505032643184038566851264109473851746507405534573077909160292816825514872584170252311902322051822644609979417178306809223
e = 65537
c = 40005881669517895877352756665523238535105922590962714344556374248977905431683140065629966778249773228248201807844489945346731806741025157651474530811920115794270396320935022110691338083709019538562205165553541077855422953438117902279834449006455379382431883650004540282758907332683496655914597029545677184720
phi=(p-1)*(q-1)
d = inverse(e,phi)
n=p*q
m = pow(c,d,n)
flag = long_to_bytes(m)
print(flag)</code></pre>
</div>

<p>常规RSA解法:</p>

<ul>
  <li>由<code class="language-plaintext highlighter-rouge">p</code>,<code class="language-plaintext highlighter-rouge">q</code>求<code class="language-plaintext highlighter-rouge">n</code>和欧拉函数<code class="language-plaintext highlighter-rouge">phi</code></li>
  <li>由<code class="language-plaintext highlighter-rouge">e</code>,<code class="language-plaintext highlighter-rouge">phi</code>求逆元<code class="language-plaintext highlighter-rouge">d</code></li>
  <li>由<code class="language-plaintext highlighter-rouge">c</code>,<code class="language-plaintext highlighter-rouge">d</code>,<code class="language-plaintext highlighter-rouge">n</code>求<code class="language-plaintext highlighter-rouge">m</code></li>
  <li>整数<code class="language-plaintext highlighter-rouge">m</code>转为字节流</li>
</ul>

<h2 id="rsa1p2">[RSA1]P2</h2>

<div class="code-snippet">
  <div class="code-header">
    <span class="file-name">main2.py</span>
  </div>
  <pre><code class="language-python">from Crypto.Util.number import inverse,long_to_bytes
'''
flag = b'NSSCTF{******}'
p = getPrime(256)
q = getPrime(256)
n = p*q
e = 65537
phi = (p-1)*(q-1)
m = bytes_to_long(flag)
c = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')
'''
n = 7382582015733895208810490097582153009797420348201515356767397357174775587237553842395468027650317457503579404097373070312978350435795210286224491315941881
e = 65537
c = 6511001389892474870028836129813814173158254564777610289284056550272120510686249909340499673868720839756059423749304765055919251717618117507007046973023557


p=70538125404512947763739093348083497980212021962975762144416432920656660487657
q=104660876276442216612517835199819767034152013287345576481899196023866133215633
phi=(p-1)*(q-1)
d = inverse(e,phi)
m=pow(c,d,n)
print(long_to_bytes(m))</code></pre>
</div>

<p>n可分解:</p>

<ul>
  <li>用<a href="https://factordb.com/">factordb</a>或<code class="language-plaintext highlighter-rouge">yafu</code>分解<code class="language-plaintext highlighter-rouge">n</code>得到<code class="language-plaintext highlighter-rouge">p</code>,<code class="language-plaintext highlighter-rouge">q</code></li>
  <li>常规RSA解法</li>
</ul>

<p>[RSA1]P3</p>

<div class="code-snippet">
  <div class="code-header">
    <span class="file-name">main3.py</span>
  </div>
  <pre><code class="language-python">from Crypto.Util.number import inverse,long_to_bytes
flag = b'NSSCTF{******}'
'''
p = getPrime(128)
q = getPrime(128)
n = p*q
e = 65537
phi = (p-1)*(q-1)
m = bytes_to_long(flag)
c = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')
'''
n = 53690629441472827148854210396580805205350972614395425306316047967905824330731
e = 65537
c = 22130296334673852790451396673112575082637108306697684532954477845025885087040


p=193584665240506752994134779660255197091
q=277349599849597463956171076348973750041
phi = (p-1)*(q-1)
d = inverse(e,phi)
m = pow(c,d,n)
print(long_to_bytes(m))</code></pre>
</div>

<p>n可分解</p>

<p>[RSA1]P4</p>

<div class="code-snippet">
  <div class="code-header">
    <span class="file-name">main4.py</span>
  </div>
  <pre><code class="language-python">from Crypto.Util.number import inverse,long_to_bytes
from gmpy2 import isqrt,next_prime
'''
flag = b'NSSCTF{******}'
p = getPrime(512)
q = gmpy2.next_prime(p)
n = p*q
e = 65537
phi = (p-1)*(q-1)
m = bytes_to_long(flag)
c = pow(m, e, n)
print(f'n = {n}')
print(f'e = {e}')
print(f'c = {c}')
'''
n = 115637000420176820831322601039129424406844427046456738651883381559357542765613732363445112111006849040385859313572091386802534464534403117787314180179562651607533039692795522388596550968316951090748054495960090527479954143448774136390568881020918710834542819900918984139672802889774720153267841255456602500057
e = 65537
c = 98161406745910866780822530171878255235776133393411573803496865047700715941955255328757920065032397556905095591171977170479344602512244671081108703687450560269408412671849929423399172588599903975793985819498354819305128607934552101433664794909855378636055525016664559476808490723554481335856183927702549281730
sn=isqrt(n)
q=next_prime(sn)
p=n//q
phi=(p-1)*(q-1)
d = inverse(e, phi)
m = pow(c, d, n)
print(long_to_bytes(m))</code></pre>
</div>

<p><code class="language-plaintext highlighter-rouge">p</code>,<code class="language-plaintext highlighter-rouge">q</code>接近</p>

<ul>
  <li>$n = p \times q$</li>
  <li>$\text{sn} = \sqrt{n}$</li>
  <li>$q = \mathrm{next\_prime}(p)$</li>
  <li>$p = \left\lfloor \frac{n}{q} \right\rfloor$</li>
  <li>常规RSA解法</li>
</ul>

      </div>
    </main>
    <footer>
        <p>&copy; 2025 版权所有</p>
    </footer>
</body>
</html>
